"""Здесь находятся функции для работы с векторами"""

import math


def add_val (vec, val):
    """Добавляем число к элементам вектора"""
    return [val + x for x in vec]


def add_vec (vec1, vec2):
    """Суммируем два вектора"""
    return list (map (lambda a, b: a + b, vec1, vec2))


def sub_vec (vec1, vec2):
    """Вычитаем второй вектор из первого"""
    return list (map (lambda a, b: a - b, vec1, vec2))


def scale (vec, k):
    """Умножаем компоненты вектора на число"""
    return [k * x for x in vec]


def vlen (vec):
    """Вычисляем длину вектора"""
    return math.sqrt (sum (x * x for x in vec))


def normalize (vec):
    """Возвращаем нормализованный вектор, если его длина не 0. Если 0, то ValueError"""
    vl = vlen (vec)
    if vl > 0.0000001:
        return [x / vl for x in vec]
    else:
        raise ValueError ("Нормализация вектора с нулевой длиной")


def dot_product (vec1, vec2):
    """Возвращает скалярное произведение векторов"""
    return sum (map (lambda a, b: a * b, vec1, vec2))


def cross_product (vec1, vec2):
    """Возвращает векторное произведение векторов"""
    return [
        vec1 [1] * vec2 [2] - vec1 [2] * vec2 [1],
        vec1 [2] * vec2 [0] - vec1 [0] * vec2 [2],
        vec1 [0] * vec2 [1] - vec1 [1] * vec2 [0]
    ]


def mirror_vector_under_90 (vec, N):
    """Возвращает вектор, отраженный по указанной нормали (длиной 1), но если угол между ними не больше 90 градусов"""
    # Умножаем вектор на -1, что бы его направление стало в ту же сторону от поверхности, что и у нормали
    # Скалярное произведение равно длине проекции vec на нормаль, с учетом, что длина нормали = 1
    # Здесь не нормализуем, т.к. нормаль должна передаваться правильно, а просто для перестраховки не оптимально
    dotp = dot_product (N, scale (vec, -1))

    # Если скалярное произведение меньше 0, значит угол больше 90 градусов
    if dotp < 0:
        return None

    # Далее, находим вектор-проекцию -vec на нормаль. Прибавив его дважды к vec, получим отраженный вектор
    # В коде эти вычисления эквивалентны, но немного оптимизированы
    return add_vec (vec, scale (N, dotp * 2))
